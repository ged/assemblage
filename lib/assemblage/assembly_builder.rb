# -*- ruby -*-
# frozen_string_literal: true

require 'tmpdir'
require 'configurability'

require 'assemblage' unless defined?( Assemblage )



# An object that provides the logic for how to build an assembly.
class Assemblage::AssemblyBuilder
	extend Configurability


	# The stages of the assembly run by the builder.
	ASSEMBLY_STAGES = %i[
		clone_repo
		prep_assembly
		execute_assembly
		wait_for_completion
		gather_results
		clean_up
	]


	configurability( 'assemblage/builder' ) do

		##
		# The directory the build does its work in
		setting :work_dir, default: Dir.tmpdir

	end


	### Create a new AssemblyBuilder from the specified +assembly_info+, which
	### should be a Hash of assembly infomation such as that created by
	### Assembly#to_hash.
	def initialize( assembly_info )
		@id         = assembly_info[:id]
		@name       = assembly_info[:name]
		@repository = assembly_info[:repository]

		@fiber      = nil
	end


	######
	public
	######

	##
	# The ID of the assembly the builder is working on
	attr_reader :id

	##
	# The name of the assembly the builder is working on
	attr_reader :name

	##
	# The Hash of repository information that describes where the builder will check
	# out the working directory from.
	attr_reader :repository

	##
	# The Fiber which is running the build
	attr_reader :fiber


	### Start building the assembly.
	def start
		@fiber = Fiber.new( &self.method(:build) )
	end


	### Resume building the assembly.
	def resume
		return self.fiber.resume
	end


	### Build the assembly, yielding control to the worker on long-running
	### stages.
	def build
		return ASSEMBLY_STAGES.reduce( {status: nil} ) do |result, stage_name|
			self.fiber.yield( nil )
			self.build_stage( stage_name, result )
		end
	end


	### Run the specified +stage_name+ of the build and yield control of the fiber
	### according to its success or failure.
	def build_stage( stage_name, result )
		build_method = self.method( stage_name )
		return build_method.call( result )
	rescue => err
		self.log.error "%p while running stage %p: %s" % [ err.class, stage_name, err.message ]
		return result.merge({
			status: 'failed',
			stage: stage_name,
			description: err.message
		})
	end



	### Builder stage: Clone the assembly's repo.
	def clone_repo( result )
		repo_url = self.repository[ :url ] or raise "No repository URL for this assembly?!"
		repo_type = self.repository[ :type ] or raise "No repository type set for this assembly."
		repo_name = self.repository[ :client_name ] || self.name
		work_dir = Dir.mktmpdir( [self.name, "assemblies"], self.class.work_dir )

		vcs = Assemblage::VCSStrategy.get_subclass( repo_type )
		vcs.clone( repo_url, work_dir )

		return result.merge( work_dir: work_dir )
	end


	### Builder stage: Set up the working copy of the repo to build the assembly.
	def prep_assembly( result )

	end


	### Builder stage: Execute the assembly script.
	def execute_assembly( result )

	end


	### Builder stage: Wait for the assembly script to be finished.
	def wait_for_completion( result )

	end


	### Builder stage: Gather the results generated by the assembly script.
	def gather_results( result )

	end


	### Builder stage: Clean up the repo.
	def clean_up( result )

	end


end # class Assemblage::AssemblyBuilder
